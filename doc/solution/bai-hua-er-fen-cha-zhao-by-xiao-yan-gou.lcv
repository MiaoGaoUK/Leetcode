### 白话题目：

有一个数组，你要分割成m份，每一份都有一个和
这些和当中的最大值
你要让它最小。假如我们设这个值为`x`

### 二分查找的思路

即我们要在一个范围内，查找我们想要的这个值`x`

#### 二分查找的范围

要进行二分查找，首先要找到一个范围
你觉得这个x最小能多小？肯定大于等于整个数组的最大值
你觉得这个x最大能多大？肯定小于等于整个数组的和

所以二分查找的范围是`[max(数组), sum(数组)]`

#### 进行二分查找

二分查找本质上就是每次测试范围的中点是大了还是小了
从而缩小查找的范围

#### 如何看这个中点值是大了还是小了？

每次：
假设这个中点`mid`就是 “每一个数组和中的最大值” 的最小值
那么`每一个数组和必定<=mid`
你用这个值来对数组进行从头分割，一旦`当前数组和>mid`,就结束该数组，开启一个新数组
如果你用这个mid创建的数组数量，比`m`还多，说明你这个值定小了，所以二分查找取哪一半？右半！
如果你用这个mid创建的数组数量，比`m`少了，说明你这个值定大了，所以二分查找取哪一半？左半！

#### 二分查找的结束

当你的查找范围只剩一个数的时候，结束二分查找

&ensp;
附加部分 (这部分不影响整体思路的理解，但和实现细节相关。可以看完此题解后再返回来思考此部分):
如果`创建数组数量`已经等于`m`了, 会发生什么？
如果`创建数组数量`已经等于`m`了, 但此时如果收敛范围仍然不止一个数，范围还是会继续收敛的，且取的是左半边，目的是让我们能最终找到一个确切的值，这个值恰好就是取得了最大值的那个数组的和 (因为小于这个和的话，就不能通过`创建数组数量=m`的测试；而大于这个m的话，即使通过了`创建数组数量=m`的测试，范围也会继续向左边收敛，直到我们找到的就是这个和。) 对于这个附加部分的理解，可以试试用[1,7,2,8,5], m=3的例子手推一遍，也许可以帮助理解

#### 编程任务

所以我们的编程任务就是：
1.指定查找范围
2.定义测试中点的函数
3.进行二分查找

#### Python代码

![截屏2020-07-25 下午9.47.56.png](https://pic.leetcode-cn.com/e17205af411ab2c796df16707e118fc7e435af6217be2d977f33a78162fd6152-%E6%88%AA%E5%B1%8F2020-07-25%20%E4%B8%8B%E5%8D%889.47.56.png)

* python

```python
class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        #二分查找

        #指定二分查找范围
        left, right = max(nums), sum(nums)

        #定义 测试中点是大还是小的 测试函数
        def test_mid(mid):
            #初始化
            num = 1 #num表示使用该mid我们会得到几个数组
            s = 0 #s表示当前数组的和

            for i in nums:
                if s+i > mid: #如果当前数组已经超过mid，要停止这个数组
                    s = i #这个数变为下一个数组的开头
                    num += 1 #会得到的数组数量+1
                else:
                    s += i

            return num > m #数组总数是否>m, 大于的话说明mid太小，二分查找取右边
            #这里有一个注意点，如果num已经等于m了, 但此时如果left不等于right，范围还是会继续收敛的，
            #且取的是左半边，目的是让我们能最终找到一个确切的值，这个值恰好就是取得了最大值的那个数组的和
            #(因为小于这个和的话，就不能通过num=m的测试；而大于这个m的话，即使通过了num=m的测试，
            #范围也会继续向左边收敛，直到我们找到的就是这个和)。
        
        #进行二分查找
        while left < right: #当left == right的时候就终止查找，返回任意一个
            mid = (left + right) // 2
            if_right = test_mid(mid)
            if if_right:
                left = mid+1
            else:
                right = mid #num <= m的情况

        return left
```

