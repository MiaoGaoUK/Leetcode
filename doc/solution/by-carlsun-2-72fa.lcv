![image.png](https://pic.leetcode-cn.com/1659060155-rFmARj-image.png)

ä¸ºäº†åˆ©äºå½•å‹ä»¬ç†è§£ï¼Œæˆ‘ç‰¹æ„å½•åˆ¶äº†è§†é¢‘ï¼Œ[æ‹¿ä¸‹èºæ—‹çŸ©é˜µï¼LeetCodeï¼š59.èºæ—‹çŸ©é˜µII](https://www.bilibili.com/video/BV1SL4y1N7mV)ï¼Œç»“åˆè§†é¢‘ä¸€èµ·çœ‹ï¼Œäº‹åŠåŠŸå€ï¼

## æ€è·¯

è¿™é“é¢˜ç›®å¯ä»¥è¯´åœ¨é¢è¯•ä¸­å‡ºç°é¢‘ç‡è¾ƒé«˜çš„é¢˜ç›®ï¼Œ**æœ¬é¢˜å¹¶ä¸æ¶‰åŠåˆ°ä»€ä¹ˆç®—æ³•ï¼Œå°±æ˜¯æ¨¡æ‹Ÿè¿‡ç¨‹ï¼Œä½†å´ååˆ†è€ƒå¯Ÿå¯¹ä»£ç çš„æŒæ§èƒ½åŠ›ã€‚**

è¦å¦‚ä½•ç”»å‡ºè¿™ä¸ªèºæ—‹æ’åˆ—çš„æ­£æ–¹å½¢çŸ©é˜µå‘¢ï¼Ÿ

ç›¸ä¿¡å¾ˆå¤šåŒå­¦åˆšå¼€å§‹åšè¿™ç§é¢˜ç›®çš„æ—¶å€™ï¼Œä¸Šæ¥å°±æ˜¯ä¸€æ³¢åˆ¤æ–­çŒ›å¦‚è™ã€‚

ç»“æœè¿è¡Œçš„æ—¶å€™å„ç§é—®é¢˜ï¼Œç„¶åå¼€å§‹å„ç§ä¿®ä¿®è¡¥è¡¥ï¼Œæœ€åå‘ç°æ”¹äº†è¿™é‡Œé‚£é‡Œæœ‰é—®é¢˜ï¼Œæ”¹äº†é‚£é‡Œè¿™é‡Œåˆè·‘ä¸èµ·æ¥äº†ã€‚

å¤§å®¶è¿˜è®°å¾—æˆ‘ä»¬åœ¨è¿™ç¯‡æ–‡ç« [æ•°ç»„ï¼šæ¯æ¬¡é‡åˆ°äºŒåˆ†æ³•ï¼Œéƒ½æ˜¯ä¸€çœ‹å°±ä¼šï¼Œä¸€å†™å°±åºŸ](https://programmercarl.com/0704.äºŒåˆ†æŸ¥æ‰¾.html)ä¸­è®²è§£äº†äºŒåˆ†æ³•ï¼Œæåˆ°å¦‚æœè¦å†™å‡ºæ­£ç¡®çš„äºŒåˆ†æ³•ä¸€å®šè¦åšæŒ**å¾ªç¯ä¸å˜é‡åŸåˆ™**ã€‚

è€Œæ±‚è§£æœ¬é¢˜ä¾ç„¶æ˜¯è¦åšæŒå¾ªç¯ä¸å˜é‡åŸåˆ™ã€‚

æ¨¡æ‹Ÿé¡ºæ—¶é’ˆç”»çŸ©é˜µçš„è¿‡ç¨‹:

* å¡«å……ä¸Šè¡Œä»å·¦åˆ°å³
* å¡«å……å³åˆ—ä»ä¸Šåˆ°ä¸‹
* å¡«å……ä¸‹è¡Œä»å³åˆ°å·¦
* å¡«å……å·¦åˆ—ä»ä¸‹åˆ°ä¸Š

ç”±å¤–å‘å†…ä¸€åœˆä¸€åœˆè¿™ä¹ˆç”»ä¸‹å»ã€‚

å¯ä»¥å‘ç°è¿™é‡Œçš„è¾¹ç•Œæ¡ä»¶éå¸¸å¤šï¼Œåœ¨ä¸€ä¸ªå¾ªç¯ä¸­ï¼Œå¦‚æ­¤å¤šçš„è¾¹ç•Œæ¡ä»¶ï¼Œå¦‚æœä¸æŒ‰ç…§å›ºå®šè§„åˆ™æ¥éå†ï¼Œé‚£å°±æ˜¯**ä¸€è¿›å¾ªç¯æ·±ä¼¼æµ·ï¼Œä»æ­¤offeræ˜¯è·¯äºº**ã€‚

è¿™é‡Œä¸€åœˆä¸‹æ¥ï¼Œæˆ‘ä»¬è¦ç”»æ¯å››æ¡è¾¹ï¼Œè¿™å››æ¡è¾¹æ€ä¹ˆç”»ï¼Œæ¯ç”»ä¸€æ¡è¾¹éƒ½è¦åšæŒä¸€è‡´çš„å·¦é—­å³å¼€ï¼Œæˆ–è€…å·¦å¼€å³é—­çš„åŸåˆ™ï¼Œè¿™æ ·è¿™ä¸€åœˆæ‰èƒ½æŒ‰ç…§ç»Ÿä¸€çš„è§„åˆ™ç”»ä¸‹æ¥ã€‚

é‚£ä¹ˆæˆ‘æŒ‰ç…§å·¦é—­å³å¼€çš„åŸåˆ™ï¼Œæ¥ç”»ä¸€åœˆï¼Œå¤§å®¶çœ‹ä¸€ä¸‹ï¼š

![image.png](https://pic.leetcode-cn.com/1659060179-wVWQcg-image.png)

è¿™é‡Œæ¯ä¸€ç§é¢œè‰²ï¼Œä»£è¡¨ä¸€æ¡è¾¹ï¼Œæˆ‘ä»¬éå†çš„é•¿åº¦ï¼Œå¯ä»¥çœ‹å‡ºæ¯ä¸€ä¸ªæ‹è§’å¤„çš„å¤„ç†è§„åˆ™ï¼Œæ‹è§’å¤„è®©ç»™æ–°çš„ä¸€æ¡è¾¹æ¥ç»§ç»­ç”»ã€‚

è¿™ä¹Ÿæ˜¯åšæŒäº†æ¯æ¡è¾¹å·¦é—­å³å¼€çš„åŸåˆ™ã€‚

ä¸€äº›åŒå­¦åšè¿™é“é¢˜ç›®ä¹‹æ‰€ä»¥ä¸€ç›´å†™ä¸å¥½ï¼Œä»£ç è¶Šå†™è¶Šä¹±ã€‚

å°±æ˜¯å› ä¸ºåœ¨ç”»æ¯ä¸€æ¡è¾¹çš„æ—¶å€™ï¼Œä¸€ä¼šå·¦å¼€å³é—­ï¼Œä¸€ä¼šå·¦é—­å³é—­ï¼Œä¸€ä¼šåˆæ¥å·¦é—­å³å¼€ï¼Œå²‚èƒ½ä¸ä¹±ã€‚

ä»£ç å¦‚ä¸‹ï¼Œå·²ç»è¯¦ç»†æ³¨é‡Šäº†æ¯ä¸€æ­¥çš„ç›®çš„ï¼Œå¯ä»¥çœ‹å‡ºwhileå¾ªç¯é‡Œåˆ¤æ–­çš„æƒ…å†µæ˜¯å¾ˆå¤šçš„ï¼Œä»£ç é‡Œå¤„ç†çš„åŸåˆ™ä¹Ÿæ˜¯ç»Ÿä¸€çš„å·¦é—­å³å¼€ã€‚

æ•´ä½“C++ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // ä½¿ç”¨vectorå®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„
        int startx = 0, starty = 0; // å®šä¹‰æ¯å¾ªç¯ä¸€ä¸ªåœˆçš„èµ·å§‹ä½ç½®
        int loop = n / 2; // æ¯ä¸ªåœˆå¾ªç¯å‡ æ¬¡ï¼Œä¾‹å¦‚nä¸ºå¥‡æ•°3ï¼Œé‚£ä¹ˆloop = 1 åªæ˜¯å¾ªç¯ä¸€åœˆï¼ŒçŸ©é˜µä¸­é—´çš„å€¼éœ€è¦å•ç‹¬å¤„ç†
        int mid = n / 2; // çŸ©é˜µä¸­é—´çš„ä½ç½®ï¼Œä¾‹å¦‚ï¼šnä¸º3ï¼Œ ä¸­é—´çš„ä½ç½®å°±æ˜¯(1ï¼Œ1)ï¼Œnä¸º5ï¼Œä¸­é—´ä½ç½®ä¸º(2, 2)
        int count = 1; // ç”¨æ¥ç»™çŸ©é˜µä¸­æ¯ä¸€ä¸ªç©ºæ ¼èµ‹å€¼
        int offset = 1; // éœ€è¦æ§åˆ¶æ¯ä¸€æ¡è¾¹éå†çš„é•¿åº¦ï¼Œæ¯æ¬¡å¾ªç¯å³è¾¹ç•Œæ”¶ç¼©ä¸€ä½
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // ä¸‹é¢å¼€å§‹çš„å››ä¸ªforå°±æ˜¯æ¨¡æ‹Ÿè½¬äº†ä¸€åœˆ
            // æ¨¡æ‹Ÿå¡«å……ä¸Šè¡Œä»å·¦åˆ°å³(å·¦é—­å³å¼€)
            for (j = starty; j < n - offset; j++) {
                res[startx][j] = count++;
            }
            // æ¨¡æ‹Ÿå¡«å……å³åˆ—ä»ä¸Šåˆ°ä¸‹(å·¦é—­å³å¼€)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // æ¨¡æ‹Ÿå¡«å……ä¸‹è¡Œä»å³åˆ°å·¦(å·¦é—­å³å¼€)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // æ¨¡æ‹Ÿå¡«å……å·¦åˆ—ä»ä¸‹åˆ°ä¸Š(å·¦é—­å³å¼€)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // ç¬¬äºŒåœˆå¼€å§‹çš„æ—¶å€™ï¼Œèµ·å§‹ä½ç½®è¦å„è‡ªåŠ 1ï¼Œ ä¾‹å¦‚ï¼šç¬¬ä¸€åœˆèµ·å§‹ä½ç½®æ˜¯(0, 0)ï¼Œç¬¬äºŒåœˆèµ·å§‹ä½ç½®æ˜¯(1, 1)
            startx++;
            starty++;

            // offset æ§åˆ¶æ¯ä¸€åœˆé‡Œæ¯ä¸€æ¡è¾¹éå†çš„é•¿åº¦
            offset += 1;
        }

        // å¦‚æœnä¸ºå¥‡æ•°çš„è¯ï¼Œéœ€è¦å•ç‹¬ç»™çŸ©é˜µæœ€ä¸­é—´çš„ä½ç½®èµ‹å€¼
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

## ç±»ä¼¼é¢˜ç›®

* 54.èºæ—‹çŸ©é˜µ
* å‰‘æŒ‡Offer 29.é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```Java
class Solution {
    public int[][] generateMatrix(int n) {
        int loop = 0;  // æ§åˆ¶å¾ªç¯æ¬¡æ•°
        int[][] res = new int[n][n];
        int start = 0;  // æ¯æ¬¡å¾ªç¯çš„å¼€å§‹ç‚¹(start, start)
        int count = 1;  // å®šä¹‰å¡«å……æ•°å­—
        int i, j;

        while (loop++ < n / 2) { // åˆ¤æ–­è¾¹ç•Œåï¼Œloopä»1å¼€å§‹
            // æ¨¡æ‹Ÿä¸Šä¾§ä»å·¦åˆ°å³
            for (j = start; j < n - loop; j++) {
                res[start][j] = count++;
            }

            // æ¨¡æ‹Ÿå³ä¾§ä»ä¸Šåˆ°ä¸‹
            for (i = start; i < n - loop; i++) {
                res[i][j] = count++;
            }

            // æ¨¡æ‹Ÿä¸‹ä¾§ä»å³åˆ°å·¦
            for (; j >= loop; j--) {
                res[i][j] = count++;
            }

            // æ¨¡æ‹Ÿå·¦ä¾§ä»ä¸‹åˆ°ä¸Š
            for (; i >= loop; i--) {
                res[i][j] = count++;
            }
            start++;
        }

        if (n % 2 == 1) {
            res[start][start] = count;
        }

        return res;
    }
}
```

* []

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        nums = [[0] * n for _ in range(n)]
        startx, starty = 0, 0               # èµ·å§‹ç‚¹
        loop, mid = n // 2, n // 2          # è¿­ä»£æ¬¡æ•°ã€nä¸ºå¥‡æ•°æ—¶ï¼ŒçŸ©é˜µçš„ä¸­å¿ƒç‚¹
        count = 1                           # è®¡æ•°

        for offset in range(1, loop + 1) :      # æ¯å¾ªç¯ä¸€å±‚åç§»é‡åŠ 1ï¼Œåç§»é‡ä»1å¼€å§‹
            for i in range(starty, n - offset) :    # ä»å·¦è‡³å³ï¼Œå·¦é—­å³å¼€
                nums[startx][i] = count
                count += 1
            for i in range(startx, n - offset) :    # ä»ä¸Šè‡³ä¸‹
                nums[i][n - offset] = count
                count += 1
            for i in range(n - offset, starty, -1) : # ä»å³è‡³å·¦
                nums[n - offset][i] = count
                count += 1
            for i in range(n - offset, startx, -1) : # ä»ä¸‹è‡³ä¸Š
                nums[i][starty] = count
                count += 1                
            startx += 1         # æ›´æ–°èµ·å§‹ç‚¹
            starty += 1

        if n % 2 != 0 :			# nä¸ºå¥‡æ•°æ—¶ï¼Œå¡«å……ä¸­å¿ƒç‚¹
            nums[mid][mid] = count 
        return nums
```

* []

```javascript

/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
    let startX = startY = 0;   // èµ·å§‹ä½ç½®
    let loop = Math.floor(n/2);   // æ—‹è½¬åœˆæ•°
    let mid = Math.floor(n/2);    // ä¸­é—´ä½ç½®
    let offset = 1;    // æ§åˆ¶æ¯ä¸€å±‚å¡«å……å…ƒç´ ä¸ªæ•°
    let count = 1;     // æ›´æ–°å¡«å……æ•°å­—
    let res = new Array(n).fill(0).map(() => new Array(n).fill(0));

    while (loop--) {
        let row = startX, col = startY;
        // ä¸Šè¡Œä»å·¦åˆ°å³ï¼ˆå·¦é—­å³å¼€ï¼‰
        for (; col < startY + n - offset; col++) {
            res[row][col] = count++;
        }
        // å³åˆ—ä»ä¸Šåˆ°ä¸‹ï¼ˆå·¦é—­å³å¼€ï¼‰
        for (; row < startX + n - offset; row++) {
            res[row][col] = count++;
        }
        // ä¸‹è¡Œä»å³åˆ°å·¦ï¼ˆå·¦é—­å³å¼€ï¼‰
        for (; col > startY; col--) {
            res[row][col] = count++;
        }
        // å·¦åˆ—åšä¸‹åˆ°ä¸Šï¼ˆå·¦é—­å³å¼€ï¼‰
        for (; row > startX; row--) {
            res[row][col] = count++;
        }

        // æ›´æ–°èµ·å§‹ä½ç½®
        startX++;
        startY++;

        // æ›´æ–°offset
        offset += 2;
    }
    // å¦‚æœnä¸ºå¥‡æ•°çš„è¯ï¼Œéœ€è¦å•ç‹¬ç»™çŸ©é˜µæœ€ä¸­é—´çš„ä½ç½®èµ‹å€¼
    if (n % 2 === 1) {
        res[mid][mid] = count;
    }
    return res;
};
  

```

* []

```typescript
function generateMatrix(n: number): number[][] {
    let loopNum: number = Math.floor(n / 2);
    const resArr: number[][] = new Array(n).fill(1).map(i => new Array(n));
    let chunkNum: number = n - 1;
    let startX: number = 0;
    let startY: number = 0;
    let value: number = 1;
    let x: number, y: number;
    while (loopNum--) {
        x = startX;
        y = startY;
        while (x < startX + chunkNum) {
            resArr[y][x] = value;
            x++;
            value++;
        }
        while (y < startY + chunkNum) {
            resArr[y][x] = value;
            y++;
            value++;
        }
        while (x > startX) {
            resArr[y][x] = value;
            x--;
            value++;
        }
        while (y > startY) {
            resArr[y][x] = value;
            y--;
            value++;
        }
        startX++;
        startY++;
        chunkNum -= 2;
    }
    if (n % 2 === 1) {
        resArr[startX][startY] = value;
    }
    return resArr;
};
```

* []

```go
func generateMatrix(n int) [][]int {
    top, bottom := 0, n-1
    left, right := 0, n-1
    num := 1
    tar := n * n
    matrix := make([][]int, n)
    for i := 0; i < n; i++ {
        matrix[i] = make([]int, n)
    }
    for num <= tar {
        for i := left; i <= right; i++ {
            matrix[top][i] = num
            num++
        }
        top++
        for i := top; i <= bottom; i++ {
            matrix[i][right] = num
            num++
        }
        right--
        for i := right; i >= left; i-- {
            matrix[bottom][i] = num
            num++
        }
        bottom--
        for i := bottom; i >= top; i-- {
            matrix[i][left] = num
            num++
        }
        left++
    }
    return matrix
}
```

* []

```swift
func generateMatrix(_ n: Int) -> [[Int]] {
    var result = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)

    var startRow = 0
    var startColumn = 0
    var loopCount = n / 2
    let mid = n / 2
    var count = 1
    var offset = 1
    var row: Int
    var column: Int

    while loopCount > 0 {
        row = startRow
        column = startColumn

        for c in column ..< startColumn + n - offset {
            result[startRow][c] = count
            count += 1
            column += 1
        }

        for r in row ..< startRow + n - offset {
            result[r][column] = count
            count += 1
            row += 1
        }

        for _ in startColumn ..< column {
            result[row][column] = count
            count += 1
            column -= 1
        }

        for _ in startRow ..< row {
            result[row][column] = count
            count += 1
            row -= 1
        }

        startRow += 1
        startColumn += 1
        offset += 2
        loopCount -= 1
    }

    if (n % 2) != 0 {
        result[mid][mid] = count
    }
    return result
}
```

* []

```rust
impl Solution {
    pub fn generate_matrix(n: i32) -> Vec<Vec<i32>> {
        let mut res = vec![vec![0; n as usize]; n as usize];
        let (mut startX, mut startY, mut offset): (usize, usize, usize) = (0, 0, 1);
        let mut loopIdx = n/2;
        let mid: usize = loopIdx as usize;
        let mut count = 1;
        let (mut i, mut j): (usize, usize) = (0, 0);
        while loopIdx > 0 {
            i = startX;
            j = startY;
            
            while j < (startY + (n as usize) - offset) {
                res[i][j] = count; 
                count += 1;
                j += 1;
            }
            
            while i < (startX + (n as usize) - offset) {
                res[i][j] = count; 
                count += 1;
                i += 1;
            }
            
            while j > startY {
                res[i][j] = count;
                count += 1;
                j -= 1;
            }
            
            while i > startX {
                res[i][j] = count;
                count += 1;
                i -= 1;
            }
            
            startX += 1;
            startY += 1;   
            offset += 2; 
            loopIdx -= 1;
        }
        
        if(n % 2 == 1) {
            res[mid][mid] = count;
        }
        res
    }
}
```

* []

```php
class Solution {
    /**
     * @param Integer $n
     * @return Integer[][]
     */
    function generateMatrix($n) {
        // åˆå§‹åŒ–æ•°ç»„
        $res = array_fill(0, $n, array_fill(0, $n, 0));
        $mid = $loop = floor($n / 2);
        $startX = $startY = 0;
        $offset = 1;
        $count = 1;
        while ($loop > 0) {
            $i = $startX;
            $j = $startY;
            for (; $j < $startY + $n - $offset; $j++) {
                $res[$i][$j] = $count++;
            }
            for (; $i < $startX + $n - $offset; $i++) {
                $res[$i][$j] = $count++;
            }
            for (; $j > $startY; $j--) {
                $res[$i][$j] = $count++;
            }
            for (; $i > $startX; $i--) {
                $res[$i][$j] = $count++;
            }
            $startX += 1;
            $startY += 1;
            $offset += 2;
            $loop--;
        }
        if ($n % 2 == 1) {
            $res[$mid][$mid] = $count;
        }
        return $res;
    }
}
```

* []

```c
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–è¿”å›çš„ç»“æœæ•°ç»„çš„å¤§å°
    *returnSize = n;
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    //åˆå§‹åŒ–è¿”å›ç»“æœæ•°ç»„ans
    int** ans = (int**)malloc(sizeof(int*) * n);
    int i;
    for(i = 0; i < n; i++) {
        ans[i] = (int*)malloc(sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }

    //è®¾ç½®æ¯æ¬¡å¾ªç¯çš„èµ·å§‹ä½ç½®
    int startX = 0;
    int startY = 0;
    //è®¾ç½®äºŒç»´æ•°ç»„çš„ä¸­é—´å€¼ï¼Œè‹¥nä¸ºå¥‡æ•°ã€‚éœ€è¦æœ€ååœ¨ä¸­é—´å¡«å…¥æ•°å­—
    int mid = n / 2;
    //å¾ªç¯åœˆæ•°
    int loop = n / 2;
    //åç§»æ•°
    int offset = 1;
    //å½“å‰è¦æ·»åŠ çš„å…ƒç´ 
    int count = 1;

    while(loop) {
        int i = startX;
        int j = startY;
        //æ¨¡æ‹Ÿä¸Šä¾§ä»å·¦åˆ°å³
        for(; j < startY + n - offset; j++) {
            ans[startX][j] = count++;
        }
        //æ¨¡æ‹Ÿå³ä¾§ä»ä¸Šåˆ°ä¸‹
        for(; i < startX + n - offset; i++) {
            ans[i][j] = count++;
        }
        //æ¨¡æ‹Ÿä¸‹ä¾§ä»å³åˆ°å·¦
        for(; j > startY; j--) {
            ans[i][j] = count++;
        }
        //æ¨¡æ‹Ÿå·¦ä¾§ä»ä¸‹åˆ°ä¸Š
        for(; i > startX; i--) {
            ans[i][j] = count++;
        }
        //åç§»å€¼æ¯æ¬¡åŠ 2
        offset+=2;
        //éå†èµ·å§‹ä½ç½®æ¯æ¬¡+1
        startX++;
        startY++;
        loop--;
    }
    //è‹¥nä¸ºå¥‡æ•°éœ€è¦å•ç‹¬ç»™çŸ©é˜µä¸­é—´èµ‹å€¼
    if(n%2)
        ans[mid][mid] = count;

    return ans;
}
```

* []

```scala
object Solution {
  def generateMatrix(n: Int): Array[Array[Int]] = {
    var res = Array.ofDim[Int](n, n) // å®šä¹‰ä¸€ä¸ªn*nçš„äºŒç»´çŸ©é˜µ
    var num = 1 // æ ‡å¿—å½“å‰åˆ°äº†å“ªä¸ªæ•°å­—
    var i = 0 // æ¨ªåæ ‡
    var j = 0 // ç«–åæ ‡

    while (num <= n * n) {
      // å‘å³ï¼šå½“jä¸è¶Šç•Œï¼Œå¹¶ä¸”ä¸‹ä¸€ä¸ªè¦å¡«çš„æ•°å­—æ˜¯ç©ºç™½æ—¶
      while (j < n && res(i)(j) == 0) {
        res(i)(j) = num // å½“å‰åæ ‡ç­‰äºnum
        num += 1 // num++
        j += 1 // ç«–åæ ‡+1
      }
      i += 1 // ä¸‹ç§»ä¸€è¡Œ
      j -= 1 // å·¦ç§»ä¸€åˆ—

      // å‰©ä¸‹çš„éƒ½åŒä¸Š

      // å‘ä¸‹
      while (i < n && res(i)(j) == 0) {
        res(i)(j) = num
        num += 1
        i += 1
      }
      i -= 1
      j -= 1

      // å‘å·¦
      while (j >= 0 && res(i)(j) == 0) {
        res(i)(j) = num
        num += 1
        j -= 1
      }
      i -= 1
      j += 1

      // å‘ä¸Š
      while (i >= 0 && res(i)(j) == 0) {
        res(i)(j) = num
        num += 1
        i -= 1
      }
      i += 1
      j += 1
    }
    res
  }
}
```

------------- 

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ åˆ·é¢˜å¾ˆè¿·èŒ«ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•](https://programmercarl.com)çš„é¡ºåºåˆ·é¢˜**ï¼Œä½ ä¼šå‘ç°ç›¸è§æ¨æ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**
